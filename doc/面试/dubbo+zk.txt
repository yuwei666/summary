zookeeper
为什么zookeer作为注册中心
可以利用zk的临时节点和watch机制来实现注册中心的自动注册和发现，另外zk的数据都是存在内存中的，并且底层适用了nio多线程模型，所以性能很好。
zk注重的是一致性，集群数据不一致时，集群将不可用；如果注重可用性，所以使用Redis，Ereka，Nacos更合适
*Nio线程模型：利用操作系统NIO的API实现，Java对其API的调用进行了封装

zk和Eureka的区别
ZK是强一致性（CP）的，当节点crash后，需要进行leader选举，在这个期间，zk不可用
Eureka是（AP）,各个节点是平等的，几个节点挂掉不影响正常工作。

zk的数据结构
zk底层是树形机构，主要维护的数据是客户端的会话（session）状态和节点信息
zk在内存中构造一个一颗DataTree，维护着path到DataNode的映射，以及dataNode间的树状层级关系。
树中的节点就是Znode，Znode可以作为路径标识，也可以存储数据，可以有子ZNode，支持增删改查操作
为了提高性能，集群中每个服务节点都是将数据全量存储在内存中。所以zk适合读多写少且轻量的数据的应用场景
数据仅存储在内存中是很不安全的，所以zk采用快照及日志的方式来落盘数据，保证数据能够快速恢复。

节点类型
持久节点：会一直存储在zk树上
临时节点：当创建该节点的客户端异常关闭时，该节点也会在zk树上删除
有序节点：上面两种节点基础上，增加了节点有序的性质

watch机制
客户端可以在Znode设置watch，实现监听Znode的事实变化
Watch事件是一个一次性的触发器，当被设置了watch的数据发生变化时，则服务器将这个改变发送给设置了watch的客户端
	父节点的创建、修改、删除会触发watch事件；子节点的创建，删除会触发watch事件

命名服务
通过名字获取资源和地址。zk中可以创建一个全局唯一的路径作为名字，被命名的实体可以是机器，服务的地址，或者远程对象，包括分布式框架（RPC）中的服务地址列表，
通过命名服务，可以根据特定的名字获取资源的实体，服务地址和提供者信息。
配置管理
实际项目开发中，需要配置很多信息，如数据库连接信息，fps地址端口。分布式部署时，把这些配置信息保存到zk的Znode节点下，当要修改信息，利用watch机制通知给各个客户端，从而更改配置。
集群管理
事实监控了Znode节点的变化，一旦有机器挂了，会断开与zk的连接，对应的临时节点会被删除，其他机器会收到通知。新机器加入也是如此

zookeeper如何实现一致性的
是通过ZAB协议实现的，ZAB协议是zookeeper用来实现一致性的原子广播协议。分为三个阶段：
	1. 领导者选举阶段  从zk集群中选举出一个节点作为Leader，所有的写请求会由Leader节点处理
	2. 数据同步阶段  集群中所有节点数据要与Leader节点保持一致，如果不一致会进行同步
	3. 请求广播阶段	 当Leader节点收到写请求时，会利用两阶段提交来广播该写请求，使得写请求像事务一样在其他节点执行，达到节点上的数据实时一致
zookeeper只是尽量达到强一致性，实际上仍然只是最终一致性

为什么zk节点是奇数
ZAP协议要求必须有过半节点能正常运行，奇数个节点能增加系统的容错能力；另外偶数节点在选举时，投票可能各占一半，无法选举。

zookeeper的选举流程
对于zk集群，整个集群需要从节点中选出一个Leader，流程如下：
1. 每个节点处于观望状态，先投票给自己
2. 然后互相投票，每个节点会收到其他节点发过来的选票，先比较zxid，如果相等则比较myid，如果输了则改票，将选票放入自己的投票箱内，并将新选票发送给其他节点
3. 经过多轮投票后，每个节点都会统计自己的选票，如果超过一半和自己投的一致，则投票的节点是Leader

zookeeper的节点之间数据同步
1. 集群启动时，进行选举确定Leader和Follower和Observer，然后Leader会和其他节点数据同步，采用快照和发送diff日志的形式
2. 集群在工作过程中，所有的写交给Leader处理，从节点只处理读。Leader在收到写请求时，会通过两阶段提交机制来处理
	Leader将写请求的日志发送给其他Follower节点，Follower收到日志后进行持久化，持久化成功则发送ACK确认给Leader，Leader收到半数以上的ACK，就会开始提交，更新Leader本地的内存数据
	然后发送commit给Follower节点，Follower收到后会更新各自的本地内存数据；同时Leader节点会将写请求发送给Observer，Observer收到请求后更新数据内存
	最后Leader节点响应客户端操作成功

zookeeper常用指令
ls查看节点信息，create创建永久节点，get获取节点的值，set设置节点的值，delete删除节点的值

有3台zookeeper服务器，
	
Dubbo
Dubbo是一款高性能、轻量级的RPC框架，提供服务注册，服务发现等服务治理方案，可与Spring无缝集成

Dubbo如何完成服务导出
Dubbo会将使用@DubboService或@Service注解进行解析，获取服务参数，包括服务名、服务接口、服务超时事件、协议等，封装成ServiceBean，使用ServiceBean的export方法导出，
然后将服务注册到注册中心，如果有多个协议，多个注册中心，那么会将服务按照按个协议，单个注册中心进行注册，同时绑定一些监听器，用于监听配置中心的变更，
还会根据服务协议启动对应的web服务器tomcat、netty

Dubbo如何完成服务引入
使用@Reference来引入一个服务时，Dubbo会将注解和服务的信息解析出来，得到当前服务的服务名，服务接口，
然后去注册中心查询，得到服务的提供者信息，并存在消费者的服务目录中，同时绑定监听器监听配置中心的变更。
最后根据查询到的服务提供者信息生成服务接口的代理对象，并放入到Spring容器中作为Bean

Dubbo的架构设计
Dubbo的架构设计是非常优秀的，分为了很多层，每层都可以扩展
1. proxy	服务代理层，支持JDK动态代理，javassist代理
2. Registry	注册中心层，支持zk，redis
3. Protocol	远程调用层，支持dubbo，http
4. Transport网络传输层，支持netty，mina
5. Serialize数据序列化层，支持JSON、Hessian等序列化机制

dubbo负载均衡策略
随机：从多个服务中随机选一个，还可以设置权重，权重值越大随机概率越大；
轮询：依次调用服务，可以设置权重
最小活跃调用：统计服务器正在处理的请求，将下次请求发送到活跃越小的服务器
hash：相同参数的请求总是发送到同一个服务器

Dubbo和Spring Cloud有哪些区别？
Spring Cloud是一个微服务框架，提供了很多微服务需要的组件，是一个大的框架；
Dubbo是一个Rpc调用框架，核心是解决服务间调用的问题，侧重于服务调用，没有Spring cloud全面，但是Dubbo的服务调用性能更高，两者也可以结合到一起使用

dubbo支持哪些协议
Dubbo，基于Netty4实现；Http；WebService

dubbo有哪些内置服务容器
Spring Container 加载Spring配置，用于服务的暴露和发现；jetty容器，log4j容器

netty
主要用来做网络通信，可以用来做RPC框架的通信工作，比Http效率更高





