RocketMQ
MQ的作用
解耦：两个系统之间不再相互依赖；异步：发送完消息可以继续执行其他代码；削峰：消费者自己控制消费速度

组件
NameServer	存储broker，topic关系信息，提供负载均衡和动态扩展，类似于zk
producter	生产者，发送到RocketMQ
Consumer	消费者，从RocketMQ中接收消息并消费
Broker		消息存储，转发；同时存储着消息相关的元数据，包括消费偏移进度，主题topic，队列queue

一些基本概念
消息message		数据的最小单位，每个消息必须属于一个主题
主题topic	标识一类消息的集合，每个主题包含若干个消息，
标签tag		消息的标签，区分不同类型的消息，topic是一级分类，tag是二级分类
队列queue	存放topic中的消息，一个topic有若干个queue，无论生产者消费者，都是对Q进行操作

实现原理
nameServer注册中心集群，Producter生产者集群，Consumer集群和若干Broker组成，架构原理是：
NameServer先启动，Brocker启动时向所有NameServer注册，并保持长连接，每30s发送一次心跳，2min没有心跳则认为下线
Producter在发送消息时从NameServer获取Broker地址，并根据负载均衡算法选择一台服务器来发送消息
Consumer消费者消费的时候同样从NameServer获取Broker地址，然后主动拉取消息进行消费

事务消息实现
RocketMQ的事务消息是一种保证可靠性的机制，主要是通过两个发送和一次确认来实现的。拿订单系统为例：
生产者订单系统先发送一条half消息到Broker，half消息对消费者不可见
再创建订单，根据创建结果像Broker发送commit或rollback
生产者还可以给Broker提供回调接口，当Broker发现一段时间half消息没有收到操作指令，会主动条用此接口来查询订单是否创建成功
一旦half消息commit，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束
如果消费失败，则根据重试策略进行重试，最后还失败会进入死信队列，等待进一步处理

消息队列如何保证消息可靠性(消息不丢失)
生产者：通过confirm模式异步确认消息发送成功，在失败后的回调函数中处理失败的逻辑。 
服务端：打开持久化机制。这里涉及到两个参数，一个是建立queue的时候，持久化那个queue。另外一个是生产者发送消息的时候，把deliveryMode设置为2，让MQ把这条数据也给持久化。但是尽管如此，如果在极端情况下，在rabbitmq中内存写成功，但是还没来及持久化时，rabbitmq宕机，这部分在内存里面的数据也会丢失，不过几率很小。 
消费者：自己完成逻辑后手动提交ack。 

消息幂等性（不被重复消费）
主要思路是根据每次请求生成一个唯一key，然后进行判断和去重。可以使用内存Set，或者redis，或者数据库唯一键。

顺序消费
生产者在发送消息时，通过设置MessageQueueSelector方法，将一组有顺序的消息依次发送到对应topic下的同一个queue中，可以保证执行顺序在broker上有序执行，但是要保证consumer的消息处理正确性

死信队列
1. 死信队列也是一个消息队列，它是用来存放那些没有成功消费的消息的，通常可以用来作为消息重试
延时队列
2. 延时队列就是用来存放需要在指定时间被处理的元素的队列，通常可以用来处理一些具有过期性操作的业务，比如5分钟内未支付则取消订单

如何保证消息的高效读写
通过零拷贝技术来优化文件读写，传统的文件拷贝需要在内存中多次复制，java对零拷贝技术进行了封装，Mmap


持久化
待补充...

----------------------------------------------------------------------------
mq如何放入消息


