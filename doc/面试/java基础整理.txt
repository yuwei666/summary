JAVA基础
String为什么被设计用final修饰
为了效率，禁止被继承和重写；为了安全，String类中有很多调用底层的本地方法，如果被重写，可能被植入恶意代码。

hashMap 
允许key为null，但只允许一个，value可以为null

1.7和1.8的区别
1.7是数组+链表 1.8为数组+链表+红黑树，所以1.8查询和插入效率更高；链表插入1.7是头插法 1.8为尾插法，因为1.8需要判断元素个数；1.8的hash算法更简单，因为引入了红黑树，可以简化算法，节省cpu资源

put方法
先将插入的key通过hash算法和位运算得到下标位置，如果下标位置元素为空，则将key，value封装为Node并放入该位置；
如果不为空，则判断Node类型，如果是红黑树，则添加到红黑树中，此过程中判断是否存在key，存在则更新value；
如果类型是链表，则使用尾插法插入到最后位置，因为是尾插法，所以需要遍历链表，如果遍历过程中存在key，则更新value；否则插入到最后；插入完成后，判断链表长度是否需要转换红黑树
最后判断是否需要扩容，不需要则结束put方法

扩容
初始容量16（1<<4），负载因子0.75，元素超过乘积时，会扩容数组长度为之前的两倍（实现尽量均匀的hash分布，提高检索效率）
先生成一个数组，遍历老数组中每个下标上的链表或红黑树元素；如果是链表，则直接计算每个元素并添加到新数组中；
如果是红黑树，则计算红黑树上每个元素对应的下标，统计每个下标的元素个数，如果个数超过8，则生成红黑树，并将根节点添加到下标位置；如果是链表，则生成链表并将头节点添加到下标位置
所有元素转移完了后，将新数组赋值给HashMap对象的数组属性

hashMap不安全
在1.8中，多线程插入和扩容过程中，有可能出现数据覆盖问题。所以推荐使用ConcurrentHashMap；ConcurrentHashMap和HashMap底层数据结构一样，底层使用CAS和synchronized，是安全的

ConcurrentHashMap的扩容机制
当某个线程进行put时，如果发现ConcurrentHashMap正在扩容，那么该线程也会一起进行扩容，如果没有正在扩容，在put结束后，会判断是否超过阈值，超过则进行扩容
ConcurrentHashMap支持多个线程同时扩容，扩容时也是先生成一个数组，将数组进行分组给不同的线程进行元素转移，每个线程负责一组或多组的元素转移工作

HashMap和HashTable
HashMap没有Synchronized修饰，线程非安全，HashTable是安全的；HashMap允许key和value都是null

ArrayList和LinkedList区别
ArrayList底层基于数组，更适合随机查找，
LinkedList基于双向链表，更适合添加删除
两者都实现了List接口，但LinkedList实现了Deque接口，可以作为队列使用

List和Set
List有序，可重复，允许多个null值，可以使用遍历器Iterator遍历，也可以直接获取指定下标元素
Set无序，不可重复，只允许一个null值，只能用遍历器Iterator遍历

深拷贝和浅拷贝
对象中包含两类属性，基本数据类型和实例对象的引用。
浅拷贝只会拷贝基本数据类型的值和实例对象的引用地址，浅拷贝出来的对象的实例对象和原对象中的实例对象是同一个；深拷贝会将实例对象也拷贝，而不是地址。

==和equals的区别
==对比的是栈中的值，基本数据类型就是变量值，引用类型就是堆内存中的地址
equals：object默认也是采用==去比较，通常会重写

对JVM的理解
JVM:通过定义虚拟机，像真实计算机一样，能够运行字节码指令，可以屏蔽操作系统的细节，实现一次编写，到处运行，主流的是Hotspot（OPEN JDK、Oracle JDK）
HotSpot的架构设计
	类加载子系统：编译好的class文件转载到类加载子系统，查询并验证类文件（完成内存分配和对象赋值）
	运行时数据区：分为线程共享内存区和线程隔离内存区
		线程共享内存区：方法区和堆区，编写代码能直接操作的区域
			方法区：储存运行的常量池、字段、方法的元数据、类的元数据
			堆区：存储java对象的实例（new的对象）
		线程隔离内存区：栈区，程序计数器，本地方法栈（native method），由JVM调度的内存区域
			栈区：通过线程的方式来运行和加载方法
			程序计数器：用于线程切换
			本地方法栈：加载和运行native方法
		正常通过运行时，数据区的五个内存区域就能够完成java程序的逻辑的执行和数据交换
	执行引擎：即时编译器和垃圾回收器
		即时编译器：将字节码翻译成操作系统能够执行的cpu指令
		垃圾回收器：对内存区域的数据管理回收
本地方法接口：也就是JNI技术，通过JNI来查找并调用c或C++的实现代码，还可以通过JNI去调用操作系统的动态链接库，DLL等

什么是字节码
就是.class文件，字节码只能由虚拟机去解释执行，翻译为系统能执行的cpu执行，所以java程序无需重新编辑即可在不同的操作系统上执行

有哪些类加载器
JDK自带三种类加载器
BootstrapClassLoader：启动类加载器，分别加载%JAVA_HOME%lib的jar包，class文件；
ExtClassLoader：扩展类加载器，%JAVA_HOME%lib/ext的jar包，class文件； 是BootstrapClassLoader的子类
AppclassLoader：应用程序加载器，classPath下的类文件，是ExtClassLoader的子类

双亲委派机制
JVM加载类的时候，调用AppClassLoader的loadClass方法加载类，在这个方法中，会由父级的父级的类加载器加载，如果如果没加载到，则父类进行加载，如果也没有，则由AppClassLoader来加载。

GC如何判断对象可以被回收
引用计数法：每个对象有一个引用计数属性，新增引用时+1，释放引用时-1，计数为0的时候可以回收。可能出现A-B相互引用，如果都不再使用了，计算器=1，永远不会被回收。
可达性分析法：从GC roots开始向下搜索，搜索走过的路径为引用链。如果一个对象到GC Roots没有任何引用链相连，则证明对象不可用，可以被回收

一个对象从加载到JVM，再到被GC清除的过程
1. 用户创建一个对象，JVM从方法区中找到对象的类型信息，创建对象
2. JVM要实例化一个对象，首先从堆内存中先创建一个对象。 ->半初始化状态
3. 对象首先会分配在年轻代的edon区，经过一次minor gc，如果对象存活，就会进入suvivor区。在后续的每次gc中，如果对象一直存活，就会在suvivor区中来回拷贝，每移动一次，年龄+1。超过最大年龄15后，对象依然存活，就会进入老年代。
4. 堆中的对象，经过Full gc，就会被标记为垃圾，会被GC线程清理掉

Full GC
针对整个堆内存的GC。
如果老年代内存满了，就会产生full GC，full GC过程中会发生STW。
年轻代的空间不能过大，如果大了，很多对象挪到老年代的时候就容易溢出，产生Full GC，建议年轻代和老年代大小比例1：2；内存中不要放置很大的集合对象，也会导致Full GC

STW
Stop-The-World，是在垃圾回收算法执行过程当中，需要将JVM内存冻结的一种状态。除GC线程外，JAVA的所有线程都停止执行，native方法是可以执行的，但是不能与jvm交互。
GC优化，其实指的就是尽可能减少STW。

垃圾回收算法
标记清除算法：分为两个阶段，标记阶段：把垃圾内存标记出来；清除阶段：直接将垃圾内存回收。这种算法简单，但是会产生大量的内存碎片。
拷贝算法：解决标记清除算法的碎片问题而产生。将内存分为大小相等的两块，每次只使用一半。垃圾回收时，将当前存活的对象全部拷贝到另外一半，然后将当前这一半内存清除。这种算法没有内存碎片，但是会浪费空间，效率取决于存活对象个数。
标记压缩算法：解决拷贝算法的缺陷而产生。标记压缩算法和标记清除算法是一样的，但是在标记完成之后，不直接清理垃圾内存，而是将存活对象向另外一端移动，然后将边界外的所有内存全部清除。
三种算法各有利弊，各自适合各自的场景

JVM排查问题
对于正在运行的系统：使用jmap查看JVM内存的使用情况；使用jstack查看线程的运行情况，是否出现了阻塞，是否出现了死锁；使用jstat查看垃圾回收情况，是否出现了full gc；通过命令的结果，使用jvisualvm工具分析，
首先，初步猜测频繁发生full gc的原因，如果一直频繁full gc又没有内存溢出，那么表示full gc实际上回收了很多对象，那么这些对象最好能够在young gc时就被回收掉，避免进入老年代，
就要考虑这些对象是不是很大，所以才会年轻代放不下从而进入了老年代，尝试加大年轻代的大小，如果更改完之后full gc减少，则证明修改有效
同时还要找到占用cpu最多的线程，定位到具体方法，优化这个方法，看看能否避免某些对象的创建，从而节省内存
已经发生OOM的系统：一般生产系统都会设置当生发OOM时，生成dump文件（-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/base），
可以利用jvisualvm 等工具来分析dump文件，找到异常的实例对象和异常线程（占用CPU高），定位到具体的代码再进行分析和调试

JVM调优
一般JVM是不需要调优的，当遇到内存使用率过高，响应时间过长，频繁Full GC，或者OOM这种时，先排除代码问题，如果代码没问题，或者业务需要的大对象导致，再考虑JVM调优。
响应时间过长：可以考虑更换更换垃圾回收器为cms或者G1，再去压测看响应时间
频繁Full GC，结合对象特性调整堆大小
OOM，比较复杂，需要结合实际情况不断的调优

JVM指令
	jmap  查看内存使用情况，生成dump文件
	jstack 查看线程使用情况
	jstat 查看jvm运行时的状态信息，内存情况，gc情况等

常用的JVM参数
参数分为三种，分别是标准参数，X参数，XX参数
标准参数：以-开头，这是所有HotSpot都支持的参数
	-version， 输出java版本信息
	-help， 输出java标准参数列表
-X参数：设置参数，设置JVM内存
	-xms，分配内存的初始大小
	-xmx：内存的最大值，一般设置为相同值，避免内存的自动扩展，影响程序稳定性。
	-xmn，设置年轻代的大小，一般设置为堆空间的三分之一，因为年轻代大的话，老年代就会小。
-XX参数其中最常用的	
	# 设置年轻代大小
	java -XX:NewSizeo=xxx
	# 设置年轻代和老年代的比例为1:2
	java -XX:NewRatio=2 -jar your-application.jar
	# Eden区和Survivor区的比例会影响对象晋升老年代的速度。适当调整这个比例可以优化对象在年轻代的存活时间，减少老年代的压力
	java -XX:SurvivorRatio=8 -jar your-application.jar
	# 使用G1垃圾回收器启动Java应用。合适的垃圾回收器能够提高应用的响应速度和吞吐量。
	java -XX:+UseG1GC -jar your-application.jar
JVM参数设置都是需要的时候参考文档来设置的 https://www.cnblogs.com/souyunku/p/17955045

-----------------------------------------------------------------------------------









