Mysql 
索引的原理
把无序的数据变成有序的查询，把创建索引的列的内容进行排序，生成倒排表，拼上数据地址链，查询的时候，先拿到内容，再得到地址链，从而拿到数据

##### 索引类型
普通索引：允许被索引的数据列拥有重复的值
唯一索引：保证数据的唯一性
主键索引：是特殊的唯一索引，一张表中只允许一个主键索引存在
联合索引：索引可以覆盖多个数据列
全文索引：通过建立倒排索引，极大的提高索引检索效率，解决判断字段包含的问题 ```ALTER TABLE table_name ADD FULLTEXT (column);```

索引对数据库性能的影响
通过使用索引，可以在查询的过程中使用优化隐匿器，极大的提高查询速度；但是会降低插入，删除，更新这些操作的速度，因为要同时操作索引文件。
索引文件需要占用物理空间，如果要建立聚簇索引，那么需要的空间会更大；如果非聚集索引很多，聚集索引改变，那么所有的非聚集索引都要跟着改变。

##### 索引设计原则
索引建立的原则是查询更快，占用空间更小
	1. 适合索引的列是出现在where子句中的列，或者连接子句中指定的列
	2. 基数较小的表，索引效果较差，没有必要在此列建立索引
	3. 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。
	4. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
	5. 定义有外键的数据列一定要建立索引。
	6. 更新频繁字段不适合创建索引
	7. 若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
	8. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
	9. 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
	10. 对于定义为text、image和bit的数据类型的列不要建立索引。

##### 索引的数据结构，还有优劣
索引的数据结构与引擎的实现有关，使用较多的有Hash索引，B+树索引，InnoDB默认使用B+树
Hash索引底层结构就是Hash表，因此绝大多数需求是单条数据查询时，可以选择Hash索引，性能最高，其余场景则要选择B+树
B+树
	B+树是一个平衡多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层节点之间有指针相互链接。所以B+树上的常规检索的搜索效率相当，不会出现大幅波动。
	而且基于索引的顺序扫描时，可以使用双向指针快速左右移动，效率非常高。因此B+树广泛用于数据库，文件系统等场景
Hash索引
	Hash索引就是采用特定的哈希算法，把键值换算成新的哈希值，检索时只需一次hash算法即可定位，速度非常快。
	前提是键值是唯一的，如果不是唯一的，则定位以后再根据链表往后扫描（也就是hash碰撞问题）。
	如果是范围查询，Hash索引就没办法了，因为有序的键值经过hash算法后，可能变成不连续的；Hash索引也没办法进行部分模糊匹配；Hash索引也不支持联合索引的最左匹配规则。

B和B+树的区别
B树的特点：
	1. 节点排序
	2. 一个节点了可以存多个元素，多个元素也排序了
B+树的特点：
	1. 拥有B树的特点
	2. 叶子节点之间有指针
	3. 非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序
在Mysql中一个Innodb页就是一个B+树节点，一个Innodb一默认16kb，所以一般情况下一颗两层的B+树可以存2000万条左右的数据，
然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。

索引覆盖
查询时利用索引快速查询，查询的所有字段都在当前索引的叶子节点上存在，无需回表

最左前缀原则
一个sql想利用索引，就一定要提供索引中最左边的字段，如果使用a,b,c三个字段创建联合索引，底层B+树时也是按照a,b,c三个字段从左到右比较大小排序，所以想使用联合索引，一定要提供a字段

MySql锁有哪些
按粒度分：行锁，锁粒度最小，并发度高；表锁，锁粒度最大，并发度低；间隙锁，锁的是一个区间
还可以分为：共享锁，读锁，其他事务可以读，不能写；排他锁，其他事务不能读，也不能写
还可以分为：乐观锁，不会真正上锁，通过版本号实现；悲观锁，行锁，表锁都是悲观锁

##### 慢查询优化（sql优化）
首先分析语句，看看是否加载了额外的数据列，可能是查询了多余的数据列并且抛弃掉了，也可能是加载了结果并不需要的列，这些就需要对sql语句进行分析以及重写
分析语句的执行计划，看看使用索引的情况，之后修改索引或sql，使sql尽可能的命中索引
最后是如果sql没有可优化的地步了，那么就看下是否是数据量过大，如果是的话考虑横向或者纵向的分表

Mysql引擎
MyISAM
	不支持事务，但是每次查询都是原子的；支持表级锁，每次操作都是对整个表加锁；存储表的总行数；
	一个MyISAM表有三个文件：索引文件、表结构文件、数据文件；
	采用非聚簇索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。
InnoDb
	支持ACID事务，支持事务的四种隔离级别；支持行级锁及外键约束，因此支持并发写；不存储总行数；
	一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空间，表大小受操作系统文件大小限制，一般为2G）；
	主键索引采用聚簇索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；
	最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。

事务的基本特性
ACID
原子性：事务要么全部成功，要么全部失败
一致性：状态转换的一致性。要转账100，但是账户里只有90，如果转账成功则破坏了一致性，因此事务不能成功
隔离性：事务提交前，其他事务不可见
持久性：事务提交后，修改会保存到数据库中

隔离性的隔离级别
读未提交，读到其他事务未提交的数据，也叫脏读
	某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
读已提交，两次读取的数据不一致，也叫不可重复读
	在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新了原有的数据。
可重复读，幻读
	在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的
串行，每一次读都加锁，一般不使用

ACID怎么保证的
A:undo log日志，记录了需要回滚的日志信息，回滚时撤销已经执行成功的sql
D:+redo log日志，修改会在日志中记录，宕机时可以从此日志中恢复



Mysql聚簇和非聚簇索引的区别
都是B+树的数据结构
聚簇索引
	将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，
	即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的
非聚簇索引
	叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，
	这个就有点类似一本书的目录，比如我们要找第三章第1节，那我们先在这个	目录里面找，找到对应的页码后再去对应的页码看文章。
优势：1、查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第2次查询（非覆盖索引的情况下）效率要高
	2、聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的
	3、聚簇索引适合用在排序的场合，非聚簇索引不适合
劣势：
	1、维护索引很昂贵，特别是插入新行或者主键被更新导致要分页(page split)的时候。
	建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片
	2、表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫描更慢，所以建议使用int的auto_increment作为主键
	3、如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非?叶子节点占用更多的物理空间
	InnoDB中一定有主键，主键一定是聚簇索引，不手动设置、则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的隐藏id来当作主键索引。
在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值
	MyISM使用的是非聚簇索引，没有聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。
表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。
	如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。

 
MySql的主从同步原理
主库记录数据库的所有变更记录到binlog。当binLog有变动时，log dump线程发送内容给从节点；从节点接收到内容，写到relay log文件中；
从节点sql线程读取relay log文件内容，对数据更新进行重放，最终保证主从数据库的一致性
注：主从节点使用 binglog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。
由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。
由此产生两个概念。
全同步复制：主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。
半同步复制：和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。

分区
range分区、list分区、hash分区和key分区。
扫盲：分区是将一个大表分割为多个更小的子表，每个子表被称为一个分区。分区可以根据数据的范围、列表或哈希等方式进行划分，并将数据分布在不同的分区中。
分区可以提高查询性能、减少索引大小、提高数据可靠性等。
	create  table  t(
	  id int
	)engine=innodb
	partition by range(id)(
		 partition  p0  values  less  than(10),-- 存放<10的数据
		 partition  p1  values  less  than(20)-- 存放>=10  <20的数据
	);

分表
			分区										分表
定义		将一个大表分割为多个子表					将一个大表拆分为多个独立的表
数据存储	数据按照规则存放在不同的分区中				数据根据规则分配到不同的表中
数据管理	操作整个表，无需考虑具体分区的细节			操作单个表，需跨表查询和数据合并
查询性能	提高查询性能，可以仅查询特定分区			查询性能相对较高，单个表规模较小
索引大小	索引仅适用于特定分区，索引相对较小			索引适用于整个表，索引相对较大
数据维护	数据维护相对简单，可以单独备份和优化		需要跨表操作，复杂度较高
适用场景	数据量大、查询频繁，基于时间范围进行查询	数据量巨大、横向扩展需求

什么是MVCC
多版本并发控制：
读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链

Explain语句结果中各个字段分表表示什么
type 针对单表的查询方式（全表扫描、索引）
key 实际使用的索引





