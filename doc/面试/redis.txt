Redis
持久化机制RDB和AOF
RDB：Redis DataBase，指定的时间间隔将内存中的数据以快照的形式写入磁盘
AOF：Append Only File，以日志的形式记录服务器的每一个写和删除操作
AOF更新频率高，优先使用AOF，AOF比RDB更大也更安全
RDB比AOF性能好，如果两个都配置了Redis优先加载AOF

Redis线程模型
Redis基于Reactor模式开发了网络事件处理器、文件事件处理器fileEventHandler。它是单线程的， 所以 Redis才叫做单线程的模型，它采用IO多路复用机制来同时监听多个Socket，根据Socket上的事件类
型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了 Redis内部的线程模型的简单性。
注：Reactor模式，一种事件分发模式；IO多路复用机制就是一个线程实现多个TCP连接

Redis单线程快的原因
纯内存操作；核心是基于非阻塞性的IO多路复用机制；单线程避免了多线程的频繁上下文操作带来的性能问题

数据结构
字符串，redis分布式锁，计数器、Session共享、分布式ID
hash表，key-value适合用来存储对象
列表，通过命令组合作为栈或者队列使用
集合，和列表类似，但不能重复，可以进行交集、并集、差集等操作
有序集合，设置顺序实现排行榜

分布式锁底层如何实现
1，利用setnx，如果key不存在才能获取到锁，如果存在获取不到
2. 然后还要利用lua脚本来保证多个redis操作的原子性
3. 同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约
4. 同时还要考虑到redis节点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到

Redis和Mysql保持数据一致性
先更新Mysql，再更新redis，如果redis失败，可能仍然不一致
先删除redis缓存，再更新Mysql，延迟几百毫秒再删除Redis缓存，这样就算再更新Mysql，这样就算有其他线程读了Mysql，把老数据写入到了Redis中，也会被删掉，从而保持一致性

集群策略
Redis提供了三种集群策略：主从模式、哨兵模式、Cluster模式
主从模式：这种模式比较简单，主库可以读写，并且会和从库进行数据同步，
哨兵模式：在主从的基础上新增了哨兵节点，哨兵发现主库宕机后，从从库中选择一个库作为主库，
Cluster模式：支持多主多从，按照key进行分配，使不同的key分布到不同的主节点上，每个主节点拥有自己的多个从节点，这个模式支持更大的数据容量
如果Redis要存的数据量不大，可以选择哨兵模式，如果Redis要存的数据量大，并且需要持续的扩容，那么选择Cluster模式。

主从复制的原理
集群启动时，主从库间建立连接；主库将所有数据同步给从库，从库依赖RDB完成加载，同步过程中，主库不会阻塞，在此期间的写操作记录到单独的buffer中，然后将这些操作发送给从库，从而实现主从同步。
后续主从库都可以处理读操作，写操作只能主库操作，主库完成写操作后，会将这些操作发送给从库。

缓存穿透
某一时刻大量请求的key在Redis中不存在，解决办法是使用布隆过滤器来拦截不存在的key
缓存击穿
某一个热点key失效，导致大量请求同时直接访问Mysql，解决办法是这个key不设置过期时间
缓存雪崩
缓存中一大批热点数据同时过期，导致大量请求同时访问Mysql，解决办法是过期时间增加随机值

事务实现
multi开始事务，继续发送命令后会放入到队列中，exec指令会执行队列中所有命令；discard会清空事务和队列；
watch命令用于对事务进行监控，是一个乐观锁类似于cas，在执行exec前，如果监控的数据被修改了，整个事务内的执行都会失效；可以使用unwatch取消监控

redis数据淘汰策略
1.默认为不淘汰，所有的写操作会返回错误；
2.最少使用算法淘汰
3.设置了过期事件的key使用LRU算法淘汰
4.随机淘汰 
5.设置了过期事件的key使用随机淘汰
6.设置了过期事件的key，过期事件最短的淘汰
配置：redis.conf中，设置 maxmemory-policy volatile-lru


项目中是怎么使用redis的
我们用的reids-7.0.5，持久化机制只开启了rbd，没开启aof
1.热点数据的缓存，使用redis是基于redisson实现的，系统中配置了多数据源，首页的数据是从其他数据源读取计算来的，这个数据的特点是变化快，需要连接自身表多次计算展示年月日比率，前端请求频繁，
	所以将数据每5s做一次定时任务更新redis，前端请求数据直接从缓存中获取
2.sa-token  sa-token的持久层本身封装了基于内存的默认实现，但是不满足持久化的需求。在项目中实现了SaTokenDao接口，基于redisson重写一系列方法。
3.限流 使用的是redisson封装提供的方法，原理是采用令牌桶思想和固定时间窗口，利用redis的过期机制控制时间窗口内允许通过的请求数量

4. 分布式锁 基于redisson实现
处理请求接口幂等性。。。

5. 登录时，限制登录次数及锁定时间，也是通过redis实现的

Redis 通过使用 Lua 脚本来保证一系列命令的原子性，当redis执行luna脚本时，会阻止其他其他脚本或命令的执行，知道本脚本执行完毕。







